<!DOCTYPE html>
<html>
<head>
    <title>SovannyYunCST356-lab5</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="styles/app.css">
</head>
<body>
    <section class="sectionClass">

    </section>
    <header>
        Sovanny_Yun_CST356_Lab5
    </header>
    <nav>
        <a href="Registration.html">Registration</a><br>
        <a href="Help.html">Help</a>
    </nav>
    <p>
        Intuitively, one can view a unit as the smallest testable part of an application. In procedural programming, a unit could be an entire module, but it is more commonly an individual function or procedure. In object-oriented programming, a unit is often an entire interface, such as a class, but could be an individual method.[2] Unit tests are short code fragments[3] created by programmers or occasionally by white box testers during the development process. It forms the basis for component testing.
    </p>
    <p>
        Ideally, each test case is independent from the others. Substitutes such as method stubs, mock objects,[5] fakes, and test harnesses can be used to assist testing a module in isolation. Unit tests are typically written and run by software developers to ensure that code meets its design and behaves as intended.
    </p>
    <p>
        Because some classes may have references to other classes, testing a class can frequently spill over into testing another class. A common example of this is classes that depend on a database: in order to test the class, the tester often writes code that interacts with the database. This is a mistake, because a unit test should usually not go outside of its own class boundary, and especially should not cross such process/network boundaries because this can introduce unacceptable performance problems to the unit test-suite. Crossing such unit boundaries turns unit tests into integration tests, and when such test cases fail, it may be unclear which component is causing the failure. Instead, the software developer should create an abstract interface around the database queries, and then implement that interface with their own mock object. By abstracting this necessary attachment from the code (temporarily reducing the net effective coupling), the independent unit can be more thoroughly tested than may have been previously achieved. This results in a higher-quality unit that is also more maintainable.
    </p>
    <footer>
        Copyrighted to Sovanny. This page is awesome btw.
    </footer>
</body>

</html>
